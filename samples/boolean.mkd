# Booleans

In this easy language we are going to introduce a simple language we
call **bool**:

~~~typeical
t ::= v | ( t ) | if t then t else t
v ::= true | false
~~~

This language will pass the following expression into a parse tree:

~~~typeical
parse t if ( if true then false else true ) then false else true
~~~

## Step

This is fun, but let us introduce the first *judgement* $t -> t$.

~~~typeical
judgement t -> t

---------- (E-Paran)
( t ) -> t

t1 -> t1'
------------------------------ (E-If)
if t1 then t2 else t3 -> t1'

----------------------------- (E-IfTrue)
if true then t2 else t3 -> t2

------------------------------ (E-IfFalse)
if false then t2 else t3 -> t3
~~~

Using this judgement and inference rule we can prove that the expression
from before can step to another value.

~~~typeical
prove that 
    if ( if true then false else true ) 
      then false 
      else false 
    -> t
~~~

Proves are of the form `prove (if +(judgements) then | that) judgement`,
and is on one line or indented. Proves are automatically using the
inference rules if on the simple existence form `that`. Proving harder
theorems might require interactiveness from the user, the syntax for
this is still under construction, but it might look a little like this:

```typeical
theorem "t can always step or is a value":
    if t then t -> t' or t ?= v 

prove "t can always step or is a value" by structural induction on t:
  case analysis on t:
    case true: true ?= v   
    case false: false ?= v
    case if t1 then t2 else t3: 
      case analysis on IH(t1 << t):
        case t1 ?= v: 
          case analysis on t1:
            case true: from (E-IfTrue) see t' = t2
            case false: from (E-IfFalse) see t' = t3
        case t1 -> t1':
          from (E-If) see t' = if t1' then t2 else t3 
```

Proves can be generated by the computer on the fly, but will be written
in the same format as the user would provide it. Making it pretty to
look at.

## Multi step

~~~typeical
judgement t ->* t

------- (E-Refl)
t ->* t

t -> t'
------------ (E-Step)
t ->* t'

t -> t' 
t' ->* t''
------------ (E-Trans)
t ->* t''
~~~

We can use this judgement to prove that if eventually evaluates to
a value. Using `v` is a implicit pattern match.

~~~typeical
prove that if ( if true then false else true ) then false else false ->* v 
~~~

Using `prove!` we will get the derivation.

~~~typeical
prove! that if ( if true then false else true ) then false else false ->* v 
~~~
